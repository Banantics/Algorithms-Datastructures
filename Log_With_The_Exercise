# Week 1 - Memory

## Team Bombakla

Date:
2/14/2024 - 2/18/2024
Members:
- Konstantin Apostolov
- Onno Orbekka

## Activities

Make sure to have the activities signed off regularly to ensure progress is tracked.

Set up a project in CLion to write the small programs needed in some of the activities.

### Before you start

In your projects, make sure that the `CMakeLists.txt` file contains the following line, so that potential problems appear in the "Messages" tab:

> ```text
> target_compile_options(${PROJECT_NAME} PRIVATE -Wall -Wextra -pedantic -Werror)
> ```

Make sure to check the messages after building.

### Activity 1: Printing memory addresses - I

Give the range of memory addresses occupied by the two arrays, `integers` and `doubles`, in the code listed below.
Explain why these ranges do or do not overlap.

This is how you include code listings in your markdown document:
```C
#include <stdio.h>

int sum_ints(void) {
	int integers[1024] = {1};
	for (int i = 1; i < 1024; ++i) integers[i] = integers[i - 1] + 1;
	return integers[1023];
}

double mul_doubles(int init) {
	double doubles[1024] = {init};
	for (int i = 1; i < 1024; ++i) doubles[i] = doubles[i - 1] * 0.999;
	return doubles[1023];
}

int main(void) {
	double result = mul_doubles(sum_ints());
	printf("Result = %lf\n", result);
}
```

### Activity 2: Printing memory addresses - II

Record the answer to the activity's questions here.

```C
#include <stdio.h>

int sum_ints(void) {
	int integers[1024] = {1};
	for (int i = 1; i < 1024; ++i) integers[i] = integers[i - 1] + 1;
	return integers[1023];
}

double mul_doubles(void) {
	double doubles[1024] = {sum_ints()};
	for (int i = 1; i < 1024; ++i) doubles[i] = doubles[i - 1] * 0.999;
	return doubles[1023];
}

int main(void) {
	double result = mul_doubles();
	printf("Result = %lf\n", result);
}
```


### Activity 3: Using data that is no longer alive

Record the answer to the activity's questions here.

```c
#include <stdio.h>

int * create_array(void) {
	int array[10];
	return array;
}

void print_array(int values[], size_t size) {
	printf("[%d", values[0]);
	for (size_t i = 1; i < size; ++i) printf(", %d", values[i]);
	printf("]\n");
}

int main(void) {
	int * values = create_array();
	for (int i = 0; i < 10; ++i) values[i] = i + 1;
	print_array(values, 10);
}
```

### Activity 4: Using malloc

#include <stdio.h>
#include <stdlib.h>


/// This function is used for memory allocation for count
/// @param count the memory we are gonna hold
/// @return It returns the pointer to the allocated memory block
int *allocate_memory(int count);

int main(void) {
    unsigned long *ptr1;
    float *ptr2;


    ptr1 = (unsigned long *) malloc(1 * sizeof(unsigned long));


    ptr2 = (float *) malloc(256 * sizeof(float));

    return 0;
}


int *allocate_memory(int count) {
    int *ptr;
    ptr = (int *) malloc(count * sizeof(int));
    return ptr;
}


### Activity 5: Allocating zero bytes

#include <stdio.h>
#include <stdlib.h>
int main() {
    void *ptr = malloc(0);
    printf("%p", ptr);
    return 0;
}
/*• What does the call to malloc return?
• What happens if you try to store data in the block of memory obtained by malloc (by
storing a value at the address that was returned), and why does that happen?
• Is it possible to allocate a block of memory that has a negative size?
*/

/// 1.The Malloc returns the allocated memory of size 0
/// 2.It will lead to errors because the allocated memory is not made for stroing
/// 3. No because malloc is expecting positive value

### Activity 6: Using allocated memory as an array

Record the answer to the activity's questions here.


int * create_array(size_t capacity) {
	int *ptr = (int*) malloc(capacity);
	return ptr;
}

int main( void ) {
	const size_t capacity = 24;
	int * array = create_array(capacity);
	for (size_t i = 1; i <= capacity; i++) array[i] = 42;
	for (size_t i = 1; i <= capacity; i++) {
		printf("array[%zu] = %d\n", i, array[i]);
	}
}
Fixed version with answered questions
#include <iostream>
#include <string>
#include <cstdlib>

int * create_array(size_t capacity) {
 int* ptr = (int*) malloc(capacity*sizeof(int));
 return ptr;
 }

 int main( void ) {
 const size_t capacity = 24;
 int* array = create_array(capacity);

 for (size_t i = 0; i <= capacity; i++) array[i] = 42;

 for (size_t i = 0; i <= capacity; i++) {
 printf("array[%zu] = %d\n", i, array[i]);
 }
 }
 /// • How many int elements can be stored in the block of memory allocated by the create_array function?
///• What happens when you perform an out-of-bounds access to an array that is stored in dynamically allocated memory?

///• The program listed below has two problems that both cause out-of-bounds access to the array, either directly or 
///indirectly. What are these two problems, and how can they be fixed (Include the fixed program in your logbook)?


/// 1. The int element it should give a crash but it should be a really big negative number but malloc only accepts positive number
/// 2. It should usually crash or give unexpected results also it can cause buffer overflow if we have another array close to the overflow one
/// 3. The first problem is that we dont type in the malloc the sizeof the int which we should or atleast the size we weant to occupie by the ptr
/// The second one is i think it starts from i=1 when it should start from i=0 and also the capacity is <= so if we put i=1 it will overflow

### Activity 7: Fixing a memory leak

Record the answer to the activity's questions here.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
	const int size = 1024 * 1024;
	for (int i = 0; i < size; ++i) {
		int * ptr = (int*) malloc(sizeof(int[size]));
		if (ptr != NULL) for (int j = 0; j < size; ++j) ptr[j] = j;
		else {
			printf("Failed to allocate %zu bytes of memory\n", sizeof(int[size]));
			break;
		}
	}
	puts("All done!");
}
```

### Activity 8: Dangerous `free`s

Record the answer to the activity's questions here.

### Activity 9: Using realloc

Record the answer to the activity's questions here.

```c
int main( void ) {
	float *grades = NULL;
	size_t capacity = 1024;
	for (int count = 0; count < 10000; capacity += 1024, ++count) {
		float *new_grades = (float*)realloc(grades, sizeof(float[capacity]));
		if (new_grades != NULL){
			// TODO: count how often the memory is reallocated to another memory address
			//       by comparing the memory addresses of the block before and after the reallocation
			grades = new_grades;	// make the new block the current block
		}
	}
}
```

### Activity 10: Using a dynamically sized buffer

Download the project for this activity from Blackboard.

Include your code & notes here.

## Looking back

### What we've learnt

Formulate at least one lesson learned.

### What were the surprises

Fill in...

### What problems we've encountered

Fill in...

### What was or still is unclear

Fill in...


